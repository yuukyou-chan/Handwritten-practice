## 回溯法


### 隐式回溯与显式回溯
* 隐式回溯：
    * 一般路径参数放在 DFS 数组的数中，每层都保留了当前 path 的结果路径（注意不要直对当前层的path参数进行修改）

* 显式回溯
    * 一般路径参数放在 全局 变量中，每次修改的是全局变量
    * 什么时候进行显式回溯？ 在哪里“做选择”，就在哪里“撤销”，
    * 多叉树路径和显式回溯时，
    在每一层，你进入当前节点这一动作，本身就是一个已经确定的选择。而 for 循环是在探索这个选择下的所有子分支。

逻辑：

进入节点：path.push(node.val)（这是进入本层的唯一动作）。

横向扫描：通过 for 循环，把所有子孩子都派去递归一遍。

离开节点：当所有孩子都看完了，这层任务结束，path.pop()。

### 回溯法解决问题

```javaScript
var permute = function(nums) {
    // 主函数，输入一组不重复的数字，返回它们的全排列
    let res = [];
    // 记录「路径」
    let track = [];
    // 「路径」中的元素会被标记为 true，避免重复使用
    let used = Array(nums.length).fill(false);

    // @visualize status(track)
    function backtrack(nums, track, used) {
        // 路径：记录在 track 中
        // 选择列表：nums 中不存在于 track 的那些元素（used[i] 为 false）
        // 结束条件：nums 中的元素全都在 track 中出现
        if (track.length === nums.length) {
            // 触发结束条件
            res.push([...track]);
            return;
        }

        for (let i = 0; i < nums.length; i++) {
            // 排除不合法的选择
            if (used[i]) {
                // nums[i] 已经在 track 中，跳过
                continue;
            }
            // 做选择
            // @visualize choose(nums[i])
            track.push(nums[i]);
            used[i] = true;
            // 进入下一层决策树
            backtrack(nums, track, used);
            // 取消选择
            // @visualize unchoose()
            track.pop();
            used[i] = false;
        }
    }

    backtrack(nums, track, used);
    return res;
};
```

如果需要进行去重操作，需要先对数组进行排序，然后在 backtrack 函数中添加判断条件：i > startIndex && candidates[i] === candidates[i - 1]
